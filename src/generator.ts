/**
 * Markdown Generator Module
 *
 * Formats git commit data into Obsidian Daily Log format.
 * Created by Agent 1.
 */

import type { Commit, FileChange } from './types.js'

/**
 * Generates a Daily Log markdown document from commits
 *
 * @param commits - Array of commits to include in the log
 * @returns Formatted markdown string
 */
export function generateDailyLog(commits: Commit[]): string {
  const date = commits.length > 0
    ? formatDate(commits[0].timestamp)
    : formatDate(new Date())
  const duration = calculateDuration(commits)
  const focusArea = inferFocusArea(commits)

  const sections = [
    generateHeader(date),
    generateSessionInfo(date, duration, focusArea),
    generateWorkCompleted(commits),
    generateCodeChanges(commits),
    generateCommitLog(commits),
    generateFooter(),
  ]

  return sections.join('\n\n')
}

/**
 * Generates the header section
 */
function generateHeader(date: string): string {
  return `# Daily Log - ${date}`
}

/**
 * Generates the session info section
 */
function generateSessionInfo(date: string, duration: string, focusArea: string): string {
  return [
    '## Session Info',
    `- **Date**: ${date}`,
    `- **Duration**: ${duration}`,
    `- **Focus Area**: ${focusArea}`,
  ].join('\n')
}

/**
 * Generates the work completed section with task checkboxes and timestamps
 * Sorted chronologically (oldest first)
 */
function generateWorkCompleted(commits: Commit[]): string {
  // Sort commits chronologically (oldest first)
  const sortedCommits = [...commits].sort(
    (a, b) => a.timestamp.getTime() - b.timestamp.getTime()
  )

  const tasks = sortedCommits.map((commit) => {
    const time = formatTime(commit.timestamp)
    return `- âœ… \`${time}\` ${commit.message}`
  })

  return ['## Work Completed', '### Tasks', ...tasks].join('\n')
}

/**
 * Generates the code changes section showing modified files
 * Sorted by commit timestamp (oldest first)
 */
function generateCodeChanges(commits: Commit[]): string {
  // Sort commits chronologically first
  const sortedCommits = [...commits].sort(
    (a, b) => a.timestamp.getTime() - b.timestamp.getTime()
  )

  // Build a map of file paths to their commits (first occurrence wins for chronological order)
  const fileMap = new Map<string, { commit: Commit; status: FileChange['status']; order: number }>()
  let order = 0

  for (const commit of sortedCommits) {
    for (const file of commit.files) {
      // Keep the first (earliest) change for each file
      if (!fileMap.has(file.path)) {
        fileMap.set(file.path, { commit, status: file.status, order: order++ })
      }
    }
  }

  // Sort by order (chronological)
  const sortedEntries = Array.from(fileMap.entries()).sort(
    (a, b) => a[1].order - b[1].order
  )

  const fileEntries = sortedEntries.map(([path, { commit, status }]) => {
    const statusEmoji = getStatusEmoji(status)
    return `  - ${statusEmoji} \`${path}\` - ${commit.message}`
  })

  return ['## Code Changes', '### Files Modified', ...fileEntries].join('\n')
}

/**
 * Generates the commit log section with detailed commit information
 * Sorted chronologically (oldest first)
 */
function generateCommitLog(commits: Commit[]): string {
  // Sort commits chronologically (oldest first)
  const sortedCommits = [...commits].sort(
    (a, b) => a.timestamp.getTime() - b.timestamp.getTime()
  )

  const commitEntries = sortedCommits.map((commit) => {
    const timestamp = formatTime(commit.timestamp)
    const fileCount = commit.files.length
    return [
      `**${timestamp}** - ${commit.message}`,
      `- Hash: \`${commit.hash.substring(0, 7)}\``,
      `- Author: ${commit.author}`,
      `- Files changed: ${fileCount}`,
    ].join('\n')
  })

  return ['## Commits', '```', ...commitEntries, '```'].join('\n')
}

/**
 * Generates the footer with last updated timestamp
 */
function generateFooter(): string {
  const now = new Date()
  const lastUpdated = `${formatDate(now)} ${formatTime(now)}`

  return [
    '---',
    '',
    '## Generated by git-to-daily',
    `*Last updated: ${lastUpdated}*`,
    '',
    'This log was automatically generated from git commits.',
  ].join('\n')
}

/**
 * Formats a date as YYYY-MM-DD
 */
function formatDate(date: Date): string {
  return date.toISOString().split('T')[0]
}

/**
 * Formats a time as HH:MM
 */
function formatTime(date: Date): string {
  return date.toLocaleTimeString('en-US', {
    hour: '2-digit',
    minute: '2-digit',
    hour12: false,
  })
}

/**
 * Calculates session duration from commit timestamps
 */
function calculateDuration(commits: Commit[]): string {
  if (commits.length === 0) {
    return 'N/A'
  }

  if (commits.length === 1) {
    return 'Single commit'
  }

  const timestamps = commits.map((c) => c.timestamp.getTime())
  const earliest = Math.min(...timestamps)
  const latest = Math.max(...timestamps)
  const durationMs = latest - earliest

  const hours = Math.floor(durationMs / (1000 * 60 * 60))
  const minutes = Math.floor((durationMs % (1000 * 60 * 60)) / (1000 * 60))

  if (hours > 0) {
    return `${hours}h ${minutes}m`
  }
  return `${minutes}m`
}

/**
 * Infers focus area from commit messages
 */
function inferFocusArea(commits: Commit[]): string {
  if (commits.length === 0) {
    return 'No activity'
  }

  // Extract common keywords from commit messages
  const messages = commits.map((c) => c.message.toLowerCase())

  // Check for common patterns
  if (messages.some((m) => m.includes('feat') || m.includes('feature'))) {
    return 'Feature development'
  }
  if (messages.some((m) => m.includes('fix') || m.includes('bug'))) {
    return 'Bug fixes'
  }
  if (messages.some((m) => m.includes('refactor'))) {
    return 'Refactoring'
  }
  if (messages.some((m) => m.includes('test'))) {
    return 'Testing'
  }
  if (messages.some((m) => m.includes('doc'))) {
    return 'Documentation'
  }

  // Default to general development
  return 'Development'
}

/**
 * Gets an emoji for file status
 */
function getStatusEmoji(status: FileChange['status']): string {
  switch (status) {
    case 'added':
      return 'â•'
    case 'modified':
      return 'âœï¸'
    case 'deleted':
      return 'ğŸ—‘ï¸'
    default:
      return 'ğŸ“'
  }
}
